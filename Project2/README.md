# Project2
## 简介
    在网络层模拟实现DV路由算法
## 设计思路
### DV
    设计了两个类，node,topograph
- node:节点类，主要功能有:
    + 接受消息
    + 发送消息
    + 重新计算DV信息
    + 交换DV信息
    + 周期性修改路径权重并告知邻居
- topograph:拓扑图，存储整个拓扑图的信息，负责在每个节点运行之初告诉节点们自己所连接的邻居，以及它们所能够改变权重的路径
    
    节点类所发送的消息类型如下

|字段1|字段2|字段3|字段4|意义|
|-----|----|-----|-----|----|
|0|name|DV|/|名字为name邻居的DV|
|1|src_ip|dst_ip|message|这是一条从src到dst的客户发的信息|
|2|name|new_weight|/|到名字为name邻居结点的链路代价改变|
|3|name|/|/|名字为name的邻居down信息|
|4|name|new_weight|/|名字为name的邻居recover信息，包含到它的新链路代价|


### LS（如果有时间）
    设计了两个类，router和LSGraph
- router：路由器节点
- LSGraph：拓扑图信息类

|字段1|字段2|字段3|字段4|字段5|意义|
|-----|----|-----|-----|----|----|
|0|src_ip|dst_ip|msg|/|接受到了有意义的消息|
|1|src_name|dst_name|weight|TTL|接受到路由广播包|

## 具体实现
### DV
#### node
    类中的成员变量：
- sck_input:收套接字
- sck_output：发套接字
- ip:自身的ip
- neighbour:指示了到某邻居的路径花销。dict类型，建立了邻居ip和路径权重的一一对应关系
- table:路由表，字典类型，建立了目的地址和下一条地址的一一对应关系
- DV:指示到某个节点的最佳路径开销，字典类型，建立了节点ip和路径开销的一一对应关系
- DV_neighbour:list类型；存储邻居的DV信息；依次为A,B,C,D,E，不是邻居的置为空的字典。
- changable_route:指示自己能够修改的路径。list类型，存储的是某些邻居的ip，表示它能够修改自己到这个邻居的路径权重

    类的函数：
- send_message：发送消息，（可否修改用于处理所有消息类型？对不同消息类型做出不同反应？）
- recv：接受消息（可否修改用于发送所有消息类型？
- recompute_DV:收到邻居发来的DV信息，重新计算DV，并得出新的路由表（self.table)
- send_DV：给邻居发送自己的DV信息
- pack_message:是否可以整合进send_message中？
- unpack_message：是否可以整合到需要处理消息的函数中？
- change_route：修改路径权重，并通知对应邻居。遍历自己的changeable_route列表，使用随机函数生成新的路径权重，将自身的neighbour中的路径权重信息更新，并且使用套接字向对应邻居发送路径权重变化的消息。

#### topograph
    类中的成员变量：
- name_ip
- link_cost：每一条路径的开销，类型是字典。tuple->int，tuple是由两个节点的ip组成的二元组，用来表示边，对应地有一个开销，为int类型。注意这个仅仅是初始化的开销，后续会动态变化（其实是不是不需要此函数？直接在node初始化中设置自己和邻居开销就可以？）
- ip_changeable_route:存储每一个ip所能够修改的路径信息，类型是字典，str->list,每一个ip对应一个存储了某些邻居ip的list，表示它能够修改自己到这些邻居的路径

    类的函数：
- initiaize_graph:图的初始化，如何连接，哪些节点改哪些路径之类。
- node_changeable_route:直接返回对应ip的可修改路径列表（表现为邻居ip）即可

## 遇到的问题
- 需要周期性调用send_DV，从而达到邻居之间交换DV信息的效果
- 一个全局变量记录IP，list类型即可，依次index为A,B,C,D,E（node和TopoGraph都用这个全局变量？）
- 链路通知错误的问题，比如E通过F（2）再通过A（5）到达C，那么E中的到达C的路由开销为7；在A宕掉的时候，F中到达C的路由开销变为正无穷，这时候它需要更新自己的DV信息，那么去遍历邻居的路由表，遍历E的时候，发现从E到C开销为7，那么它认为通过E可以到达C，但实际上，E是通过F和A到达C的，这条路径实际上并不能走得通，那么F就计算出了一个错误的路由信息。

- 宕掉节点的处理方法：写一个函数，宕掉节点发送自己正无穷路径的信息给邻居，邻居收到了此信息之后更新自己的路由表，将相应的位置设置为正无穷，并告知自己的邻居，

- 初始化DV信息和table的时候，还没有找到怎么到达目的地的路径时，先将cost设置为0，table转发下一跳设置为'DK'
- LS计算路由信息的时候，当自己down掉，到所有邻居都是正无穷，而LS算法开始的时候先把所有节点到自己的路径设置为正无穷，这样，执行LS算法之后，dist列表中全是正无穷，而prev为空，这时候，为了避免访问索引出错，加了一个条件判断再去索引prev。因此得到的下一跳是目的地本身。但这不影响消息的发送，因为在判断路径为正无穷之后就不会发送消息了。
- tkinter窗口大小设置上，控件初始化的时候设置了width和height参数，但是显示出来的窗口大小却不是这样(未解决)
- 在做GUI的时候，给router.py里面的几个函数加了返回的字符串,用于GUI输出
- 另外,router类的down_status成员在命令行和GUI有着不同的含义,在命令行中,只指定了一个节点down掉,所以用来指示这个节点是否将要down掉,而在GUI中,每个节点都能down掉,所有这个信息用来指示它现在是否处于down的状态.它的recover和down能否进行都取决于这个状态的改变.(虽然不太规范,直接在类外修改了类成员函数)

## 运行方法
### LS
- 在LSGraph文件中填入ip和名字的对应关系
- 在GUI_LS.py文件中对应位置填入运行此程序的本机IP,保存文件后直接运行GUI_LS.py即可
- 或者在LS_main.py文件中对应位置填入运行此程序的本机IP，保存文件后运行LS_main.py
- 注意GUI_LS 和LS_main两者只能选其一运行,总体而言,GUI运行体验更好
